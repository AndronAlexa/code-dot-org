#!/usr/bin/env ruby
#
# CI_BUILD is the core command in our polling-based continuous deployment system. It checks for upstream
# commits on the current branch.
#
# If no changes are detected it exits silently.
#
# If changes are detected, CI_BUILD fetches them, gets the commit messages for them (written out as
# the temp file 'rebuild') and displays them in chat as a purple "build started" message. Then
# CI_BUILD invokes the 'ci' Rake task to run the build.
#
# NOTE: When the build starts a BUILD-STARTED file is created, and this file is deleted when the
#   build script finishes. This file is NOT deleted if the build system itself is broken and the
#   presence of this file will cause the system to attempt to pull and rebuild constantly over and
#   over until it succeeds. This may happen often, but it is probably a safeguard to keep around because
#   in the rare cases where the build scripts are damaged, this ensures the machines can be restored simply
#   by checking in a fix (vs. needing to SSH to the machine and fix manually).
#
# NOTE: running `touch build-started` (or running the `bin/start-build` script)
# is an easy way to force a rebuild without needing to make a commit.
#
require_relative '../lib/cdo/only_one'
require 'ci_builder'
exit(0) unless only_one_running?(__FILE__)

require 'active_support/inflector'
require_relative '../deployment'
require 'cdo/aws/s3'
require 'cdo/chat_client'
require 'cdo/developers_topic'
require 'cdo/github'
require 'cdo/git_utils'
require 'cdo/honeybadger'
require 'cdo/infra_production_topic'
require 'cdo/rake_utils'
require 'cdo/test_server_status'
require 'cdo/metrics_helper'
require 'dynamic_config/dcdo'
require 'aws-sdk-cloudwatch'

STARTED = 'build-started'.freeze
def main
  start_time = Time.now
  # Run the build command and exit if it didn't do anything.
  status = 0
  log = RakeUtils.capture do
    status = CiBuilder.build
  rescue => exception
    status = "Error: #{exception.message}\n#{CDO.backtrace exception}"
  end
  return status if status == 0 && log.empty?

  Dir.chdir(deploy_dir) do
    projects = ARGV.join(' ')
    projects = 'websites' if projects.empty?

    commit_hash = RakeUtils.git_revision
    commit_hash_short = GitUtils.git_revision_short
    commit_url = "https://github.com/code-dot-org/code-dot-org/commit/#{commit_hash}"

    duration = Time.now.to_i - start_time.to_i
    formatted_duration = RakeUtils.format_duration(duration)

    # Upload build log to S3
    metadata = {
      commit: commit_hash,
      duration: duration.to_s,
      success: (status == 0).to_s
    }
    log_link = build_logger.log_build_end(status, log, metadata)
    BuildStatusNotifier.notify(status, projects, formatted_duration, log_link, commit_url, rack_env, commit_hash_short)
    emit_deploy_metric(rack_env.to_s.titleize, status == 0)
  end

  # Return the same output and status code that BUILD returned.
  puts log
  status
end

def check_hoc_mode
  hoc_mode = DCDO.get('hoc_mode', false)
  if hoc_mode != CDO.default_hoc_mode
    # The test machine cannot remember DCDO params, so its hoc_mode is controlled by
    # CDO.default_hoc_mode.
    msg = "<!here> #{rack_env} hoc_mode (#{hoc_mode.inspect}) and default_hoc_mode " \
      "(#{CDO.default_hoc_mode.inspect}) are out of sync. Please update CDO.default_hoc_mode in " \
      "github, DCDO hoc_mode in staging, and DCDO hoc_mode in production to the same values, so " \
      "that our staging, test and production environments all show the same version of our site."
    ChatClient.log msg
  end
end

def check_hoc_launch
  hoc_launch = DCDO.get('hoc_launch', false)
  if hoc_launch != CDO.default_hoc_launch
    # The test machine cannot remember DCDO params, so its hoc_launch is controlled by
    # CDO.default_hoc_launch.
    msg = "<!here> #{rack_env} hoc_launch (#{hoc_launch.inspect}) and default_hoc_launch " \
      "(#{CDO.default_hoc_launch.inspect}) are out of sync. Please update CDO.default_hoc_launch in " \
      "github, DCDO hoc_launch in staging, and DCDO hoc_launch in production to the same values, so " \
      "that our staging, test and production environments all show the same version of our site."
    ChatClient.log msg
  end
end

def emit_deploy_metric(deployment_stage, successful)
  Aws::CloudWatch::Client.new.put_metric_data(
    {
      namespace: 'DEPLOYMENTS',
      metric_data: [{
        metric_name: "#{deployment_stage}#{successful ? 'Successful' : 'Failed'}",
        value: 1
      }]
    }
  )
rescue => exception
  ChatClient.log 'Unable to emit metrics', color: 'red'
  ChatClient.log "/quote #{exception}", color: 'gray', message_format: 'text'
end

main
